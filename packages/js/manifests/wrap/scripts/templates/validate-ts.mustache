/* eslint-disable */
/**
 * This file was automatically generated by scripts/manifest/validate-ts.mustache.
 * DO NOT MODIFY IT BY HAND. Instead, modify scripts/manifest/validate-ts.mustache,
 * and run node ./scripts/manifest/generateFormatTypes.js to regenerate this file.
 */
import {
  AnyWrapManifest,
  WrapManifestVersions
} from ".";
{{#validators.length}}import * as Validators from "../validators";{{/validators.length}}
{{#formats}}
import schema_{{tsVersion}} from "@polywrap/wrap-manifest-schemas/formats/wrap.info/{{version}}.json";
import abi_schema_{{abiTsVersion}} from "@polywrap/wrap-manifest-schemas/formats/abi/{{abiVersion}}.json";
{{/formats}}

import {
  Schema,
  Validator,
  ValidationError,
  ValidatorResult
} from "jsonschema";
import {
  bundle,
  resolve,
  FileInfo,
  $Refs,
  JSONSchema
} from "json-schema-ref-parser";
import path from "path";

type WrapManifestSchemas = {
  [key in WrapManifestVersions]: Schema | undefined
};

type WrapAbiSchemas = {
  [key in WrapManifestVersions]: Schema | undefined
}

const schemas: WrapManifestSchemas = {
  // NOTE: Patch fix for backwards compatability
  "0.1.0": schema_0_1,
  {{#formats}}
  "{{version}}": schema_{{tsVersion}},
  {{/formats}}
};

const abiSchemas: WrapAbiSchemas = {
  // NOTE: Patch fix for backwards compatability
  "0.1.0": abi_schema_0_1,
  {{#formats}}
  "{{version}}": abi_schema_{{abiTsVersion}},
  {{/formats}}
}

{{#validators}}
Validator.prototype.{{.}} = Validators.{{.}};
{{/validators}}

function throwIfErrors(result: ValidatorResult, version: string) {
  if (result.errors.length) {
    throw new Error([
      `Validation errors encountered while sanitizing WrapManifest version ${version}`,
      ...result.errors.map((error: ValidationError) => error.toString())
    ].join("\n"));
  }
}

export function validateWrapManifest(
  manifest: AnyWrapManifest,
  extSchema: Schema | undefined = undefined
): void {
  const schema = schemas[manifest.version as WrapManifestVersions];
  const abiSchema = abiSchemas[manifest.version as WrapManifestVersions];

  if (!schema || !abiSchema) {
    throw new Error(`Unrecognized WrapManifest schema version "${manifest.version}"\nmanifest: ${JSON.stringify(manifest, null, 2)}`);
  }

  if (!schema.properties) {
    // This should never happen
    throw new Error(`WrapManifest schema doesn't contain any properties`)
  }

  const abiJsonSchemaRelPath = schema.properties.abi.$ref as string;

  let finalSchema: JSONSchema | undefined;

  bundle(schema as any, {
    resolve: {
      file: {
        read: (file: FileInfo) => {
          // If both url is same
          if (!path.relative(abiJsonSchemaRelPath, file.url)) {
            return abiSchema as any;
          }
          return file.data;
        },
      },
    },
  }, (err: Error | null, schema: JSONSchema | undefined) => {
    if (err) {
      throw err;
    }
    finalSchema = schema;
  });

  if (!finalSchema) {
    throw Error("bundle did not return a JSONSchema instance");
  }

  let refs: $Refs | undefined;

  resolve(finalSchema, (err: Error | null, $refs: $Refs | undefined) => {
    if (err) {
      throw err;
    }
    refs = $refs;
  });

  if (!refs) {
    throw Error("resolve did not return $Refs instance");
  }

  const validator = new Validator();
  validator.addSchema(finalSchema as Schema);

  const resolveRefs = () => {
    const unresolvedRef = validator.unresolvedRefs.shift();
    if (!unresolvedRef) return;

    const relRefIdx = unresolvedRef.indexOf("#");
    const relRef = unresolvedRef.slice(relRefIdx);

    const resolvedSchema = refs?.get(relRef);
    if (!resolvedSchema) throw new Error(`Failed to resolve the ref: ${relRef}`);
    validator.addSchema(resolvedSchema as Schema, unresolvedRef);

    resolveRefs();
  }
  
  resolveRefs();

  throwIfErrors(validator.validate(manifest, finalSchema as Schema), manifest.version);

  if (extSchema) {
    throwIfErrors(validator.validate(manifest, extSchema), manifest.version);
  }
}
